---
title: Recursive Delegation
description: Understanding what recursive delegation is and how it works.
---

import {
  Aside,
  Card,
  CardGrid,
} from "@astrojs/starlight/components";

Recursive delegation means a delegation's output can be used as another delegation's input. This enables agents to both re-delegate permissions indefinitely and optionally sub-scope them at each delegation step. 

This creates a fluid open-ended process for discovering the best-suited agent to hold a given permission at any moment and enables the partitioning of the scope of a permission granularly into a tree of agents, finding the best agent for each part. 

At each delegation step, permission's can be
- granularly partitioned into smaller permissions until reaching the atomic level
- paired with a new constraint, accumulating a constraint stack throughout the delegation path.

This applies to the capability, emission and curator permission type.

### Core Functions

* **Specialized Routing:** Agents can specialize solely on routing permissions to the best-fit agent at any given moment, recursively, meaning agent's can also specialize on routing to the best routers. This is critical for the self-organization and efficiency of the network.
* **Granular Partitioning:** A broad responsibility scope can be sub-scoped into a self-organizing tree of agents, each with precisely defined control/responsibility areas.
* **Composition:** Capability Permissions allow to compose smaller permission scopes into larger scopes from multiple parent (incoming) delegations.

#### Permission Instance System

Capability permissions apply a instance system that allows the owner of a capability path to control the number of instances of a permission upon delegation.
It takes one permission instance to utilize it, meaning if multiple permission instances are delegated then the recipient could re-delegate all except one to keep permission access. 

The root owner of a capability path can delegate any amount of permission instances, while lower levels are limited by the amount of instances available to them.

#### Rules

* **Multi-parent composition:** Capability Paths (and sub-paths) from multiple parent permissions can be composed into one child permission.
* **Granular Partitioning:** Capability Path can be be partitioned into any set of sub-paths to be re-delegated.
* **Revocation:** Revoking a delegation also revokes all sub-delegations in the same block. Child permissions cannot have looser revocation terms than their parent.
* **Constraint Inheritance:** Constraints are inherited through delegation, stacking up and acting as gates. All gates along the delegation path between the using agent and the original source agent must be passed for a permission to be exercised.
* **Delegation Depth:** Measured per permission as the number of delegation steps from the root owner to the current holder. Max: 5 (will increase in future)


### Related Concepts

- **[Permission System](https://docs.torus.network/explanations/v06/permissions/)** - Core permission mechanics and delegation basics
- **[Recursive Delegation](https://docs.torus.network/explanations/v06/recursive-delegation/)** - Permission type for offchain agent capabilities
- **[Agent Registration](https://docs.torus.network/explanations/builders/agent-registration/)** - How agents become capable of receiving delegations  
- **[Root Agents](https://docs.torus.network/explanations/goal-leaders/root-agents/)** - Agents with direct emission access for delegation

<Aside type="tip" title="Ready to Create Recursive Delegation?">
Follow our [step-by-step guide to recursive delegation](https://docs.torus.network/how-to-guides/builders/recursive-delegation/) for practical implementation instructions.
</Aside>
